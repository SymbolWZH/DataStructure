# 哈夫曼树与哈夫曼编码

## 基础知识

- 标准的 ASCII 字符集由大约100个可打印字符组成。为了把这些字符区分开来，需要 log^100 = 7个比特。但是7个比特可以表示128个字符，因此ASCII字符还可以再加上一些其他的非打印字符。我们加上第8个比特位作为奇偶校验位。不过重要的问题在于，如果字符集的大小是C，那么在标准的编码中就需要 log^C 个比特。

- 在现实中，文件可能是相当大的，许多非常大的文件是某个程序的输出数据，而在使用频率最大和最小字符之间通常存在很大的差别。那么能否有一种更好的编码降低总的所需的比特数。

- 答案是肯定的，一种简单的策略可以使一般的大型文件节省25%，而使许多大型的数据文件节省多达 50%~60%。这种一般的策略就是让代码的长度从字符到字符是变化不等的，同时保证经常出现的字符其代码短。注意，如果所有的字符都以相同的，那么要节省空间是不可能的。

- 满树：所有的结点或者是树叶，或者是树叶，或者有两个儿子。一种最优的编码将总具有这个性质，否则具有一个儿子的结点可以向上移动一层。

- 如果字符都只放在树叶上，那么任何比特序列总能够被毫无歧义地译码。这些字符编码的长度是否不同并不要紧，只要没有字符代码是别的字符代码的前缀即可。这种编码叫做前缀码（character code）。相反，如果一个字符放在非树叶结点上，那就不再能够保证译码没有二义性。

- 所以基本问题在于找到总价值最小的满二叉树，其中所有的字符都位于树叶上。

## 哈夫曼算法

- 假设字符的个数为C，那么哈夫曼算法可以描述如下：算法对一个由树组成的森林进行。一棵树的权等于他的树叶的频率的和。任意选取最小权的两棵树 T1 和 T2 ，并任意形成以 T1 和 T2 为子树的新数，将这样的过程进行 C-1 次。在算法的开始，存在C棵单节点树——每个字符一棵。在算法结束时得到一棵树，这棵树就是最优哈夫曼树。 
- 哈夫曼编码不唯一。
- 根据哈夫曼算法得到的一定是最优编码，但是最优编码不一定通过哈夫曼算法得到。

## 哈夫曼编码的特点

- 最优编码——总长度(WPL) 最小
- 无歧义解码——前缀码：数据仅存于叶子节点