# 二叉树及存储结构

## 二叉树的定义

- 二叉树：一个有穷的结点集合  
  这个集合可以为空。  
  若不为空，则它是由**根节点**和称为其**左子树**和**右子树**的两个不相交的二叉树组成。

### 特殊二叉树：
- 斜二叉树
- 完美二叉树（满二叉树）
- 完全二叉树  
有 n 个结点的二叉树，对树中结点按 从上至下、从左到右顺序进行编号， 编号为 $i（1 ≤ i ≤ n）$ 结点与满二叉树 中编号为 $i$ 结点在二叉树中位置相同。

## 二叉树的几个重要性质

- 一个二叉树第 $i$ 层的最大结点数为： $2^{ i-1}$，i $\ge$ 1。
- 深度为 $k$ 的二叉树有最大结点总数为： $2^{k}$，k $\ge$ 1。
- 对任何非空二叉树 $T$，若 $n_0$ 表示叶结点的个数、$n_2$ 是度为 2 的非叶结点个数，那么两者满足关系 $n_0$ = $n_2$ +1。

## 二叉树的抽象数据类型定义

类型名称：  二叉树   
数据对象集：一个有穷的结点集合。 若不为空，则由根结点和其左、右二叉子树组成。  
操作集： BT $\in\ $BinTree, Item $\in\ $ElementType，重要操作有：  
1、Boolean IsEmpty( BinTree BT )： 判别 BT 是否为空；  
2、void Traversal( BinTree BT )：遍历，按某顺序访问每 个结点；   
3、BinTree CreatBinTree( )：创建一个二叉树。  

## 二叉树的存储结构

### 顺序存储结构

- 完全二叉树：按从上至下、从左到右顺序存储 n个结点的完全二叉树的结点父子关系：
非根结点（序号 $ i > 1$）的父结点的序号是 $ i / 2$;
结点（序号为 $i$ ）的左孩子结点的序号是 $2i$，（若$2 i <= n$，否则没有左孩子）;
结点（序号为 $i$ ）的右孩子结点的序号是 $2i+1$， （若$2 i +1<= n$，否则没有右孩子）;
- 一般二叉树也可以按照完全二叉树的方式来存储，但是会造成空间浪费。

### 链表存储

```c
typedef struct TreeNode *BinTree;
typedef BinTree Position;
struct TreeNode {
    ElementType Data;
    BinTree Left;
    BinTree Right;
}
```

# Lecture-7 二叉树的遍历

## 先序遍历 
遍历过程为：   
① 访问根结点；   
② 先序遍历其左子树；  
③ 先序遍历其右子树。  

## 中序遍历
遍历过程为：  
① 中序遍历其左子树；   
② 访问根结点；  
③ 中序遍历其右子树。  

## 后序遍历
遍历过程为：   
① 后序遍历其左子树；   
② 后序遍历其右子树；  
③ 访问根结点。

## 层序遍历
二叉树遍历的核心问题：二维结构的线性化 

从结点访问其左、右儿子结点， 访问左儿子后，如果还想访问右儿子那么 需要一个存储结构保存暂时不访问的结点 。

存储结构：堆栈、队列  

- 采用顺序存储结构来存储二叉树，往往需要确定二叉树的根节点，其中根节点最明显的特征就是他不是任何节点的儿子，因此我们需要采用一个标记数组来确定其根节点。
- 层序遍历的方法可以使用两个队列，获得根节点后，可以按照从左到右的顺序依次将根节点的儿子压入队列，然后继续向下将儿子的儿子节点压入队列。
- 在上述过程中如果遇到叶节点，直接存入到另外一个队列中，循环结束后，返回依次存放了叶节点的队列，依次输出即可获得层序遍历顺序的叶节点。